---
phase: 01-foundation-services
plan: 04
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - services/fulfillment-worker/cmd/worker/main.go
  - services/fulfillment-worker/internal/queue/consumer.go
  - services/fulfillment-worker/internal/db/db.go
  - services/fulfillment-worker/internal/logger/logger.go
  - services/fulfillment-worker/Dockerfile
  - services/fulfillment-worker/go.mod
  - services/fulfillment-worker/go.sum
autonomous: true

must_haves:
  truths:
    - "Fulfillment Worker starts and begins consuming from Redis fulfillment_queue"
    - "Worker processes orders by updating status from pending to processing to fulfilled"
    - "Worker updates order status in PostgreSQL after processing"
    - "Worker handles empty queue gracefully with blocking pop (no busy-wait)"
    - "All operations emit structured JSON logs with correlation_id from queue message"
  artifacts:
    - path: "services/fulfillment-worker/cmd/worker/main.go"
      provides: "Entry point that initializes DB, Redis, and starts consumer loop"
      contains: "func main()"
    - path: "services/fulfillment-worker/internal/queue/consumer.go"
      provides: "Redis queue consumer using BRPOP"
      contains: "BRPop"
    - path: "services/fulfillment-worker/internal/db/db.go"
      provides: "PostgreSQL connection pool and order status updates"
      contains: "pgxpool"
    - path: "services/fulfillment-worker/internal/logger/logger.go"
      provides: "Structured JSON logging"
      contains: "json.Marshal"
    - path: "services/fulfillment-worker/Dockerfile"
      provides: "Multi-stage build container image"
      contains: "FROM golang"
    - path: "services/fulfillment-worker/go.mod"
      provides: "Go module definition"
      contains: "go-redis/v9"
  key_links:
    - from: "services/fulfillment-worker/cmd/worker/main.go"
      to: "services/fulfillment-worker/internal/queue/consumer.go"
      via: "import and function call"
      pattern: "queue\\.Consume|queue\\.New"
    - from: "services/fulfillment-worker/internal/queue/consumer.go"
      to: "redis:6379"
      via: "go-redis BRPop on fulfillment_queue"
      pattern: "BRPop.*fulfillment_queue"
    - from: "services/fulfillment-worker/internal/db/db.go"
      to: "postgres:5432"
      via: "pgx connection pool"
      pattern: "pgxpool\\.New"
---

<objective>
Build the Fulfillment Worker Go microservice -- an asynchronous queue consumer that reads order messages from Redis, simulates order processing with realistic delays, and updates order status in PostgreSQL.

Purpose: The Fulfillment Worker demonstrates the async consumer pattern using Go and Redis. It completes the order processing pipeline: Web Gateway (REST) -> Order API (gRPC + DB + queue) -> Fulfillment Worker (queue consumer + DB update). The Go service shows Go's idiomatic patterns for concurrent processing, structured logging, and graceful shutdown.

Output: Complete services/fulfillment-worker/ directory with Go worker, Redis consumer, database layer, structured logging, Dockerfile, and go.mod
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-services/01-CONTEXT.md
@.planning/phases/01-foundation-services/01-RESEARCH.md
@.planning/phases/01-foundation-services/01-01-SUMMARY.md
@docker-compose.yml
@.env
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Fulfillment Worker internal packages (logger, db, queue)</name>
  <files>
    services/fulfillment-worker/go.mod
    services/fulfillment-worker/internal/logger/logger.go
    services/fulfillment-worker/internal/db/db.go
    services/fulfillment-worker/internal/queue/consumer.go
  </files>
  <action>
    Create the Go module and internal packages:

    1. **services/fulfillment-worker/go.mod**:
       - Module: `fulfillment-worker` (or a path like `github.com/observability-sandbox/fulfillment-worker`)
       - Go version: 1.22
       - Dependencies will be resolved by `go mod tidy` but anticipate:
         - github.com/redis/go-redis/v9
         - github.com/jackc/pgx/v5

    2. **services/fulfillment-worker/internal/logger/logger.go** - Structured JSON logging:
       - Package: logger
       - LogEntry struct: Timestamp, Level, Service, Message, CorrelationID (all string, json tags)
       - Additional fields via map[string]interface{} for extensibility
       - Functions:
         - `Info(message, correlationID string, fields ...map[string]interface{})` - log at info level
         - `Error(message, correlationID string, err error, fields ...map[string]interface{})` - log at error level, include error field
         - `Warn(message, correlationID string, fields ...map[string]interface{})` - log at warn level
       - Service name hardcoded to "fulfillment-worker"
       - Output via json.Marshal + fmt.Println (Docker captures stdout)
       - Timestamp in RFC3339 UTC format

    3. **services/fulfillment-worker/internal/db/db.go** - PostgreSQL operations:
       - Package: db
       - Use pgx/v5/pgxpool for connection pooling
       - `NewPool(ctx context.Context) (*pgxpool.Pool, error)`:
         - Build connection string from env vars: POSTGRES_HOST, POSTGRES_PORT, POSTGRES_USER, POSTGRES_PASSWORD, POSTGRES_DB
         - Configure pool: MaxConns=5, MinConns=1
         - Retry connection up to 5 times with 2-second sleep between attempts
         - Return pool or error
       - `UpdateOrderStatus(ctx context.Context, pool *pgxpool.Pool, orderID int, status string) error`:
         - UPDATE orders SET status=$1, updated_at=NOW() WHERE id=$2
         - Return error if update fails or no rows affected
       - `GetOrder(ctx context.Context, pool *pgxpool.Pool, orderID int) (map[string]interface{}, error)`:
         - SELECT id, product_id, quantity, status, created_at FROM orders WHERE id=$1
         - Return map with order fields or error
       - Log all database operations using logger

    4. **services/fulfillment-worker/internal/queue/consumer.go** - Redis queue consumer:
       - Package: queue
       - OrderMessage struct: OrderID int, ProductID int, Quantity int, CorrelationID string, Timestamp string (json tags matching Python publisher format)
       - `NewRedisClient(ctx context.Context) (*redis.Client, error)`:
         - Parse REDIS_URL env var (default "redis://redis:6379")
         - Use redis.ParseURL to create options
         - Ping to verify connection, retry up to 5 times with 2-second sleep
         - Return client or error
       - `Consume(ctx context.Context, rdb *redis.Client, handler func(ctx context.Context, msg OrderMessage) error)`:
         - Infinite loop with context cancellation check
         - BRPop from "fulfillment_queue" with 5-second timeout (not 0 -- allows periodic context check for graceful shutdown)
         - On timeout, continue loop (not an error)
         - Parse JSON message into OrderMessage struct
         - Call handler function with message
         - If handler returns error, log but continue (don't crash on single message failure)
         - Log each message received and processed
       - The handler pattern allows main.go to inject processing logic including DB updates
  </action>
  <verify>
    - go.mod exists with correct module name and Go version
    - logger.go outputs JSON with all required fields (timestamp, level, service, message, correlation_id)
    - db.go uses pgxpool and parameterized queries
    - consumer.go uses BRPop with timeout and handles context cancellation
    - consumer.go defines OrderMessage struct matching the JSON format from Python publisher
  </verify>
  <done>
    Go module defined with pgx and go-redis dependencies. Logger outputs structured JSON matching the format used by Node.js and Python services. Database layer provides connection pool with retry and order status update queries. Queue consumer uses BRPop with timeout for graceful shutdown support and handler pattern for processing logic injection.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Fulfillment Worker main entry point and Dockerfile</name>
  <files>
    services/fulfillment-worker/cmd/worker/main.go
    services/fulfillment-worker/Dockerfile
  </files>
  <action>
    Create the main entry point and Docker container:

    1. **services/fulfillment-worker/cmd/worker/main.go** - Worker entry point:
       - Package: main
       - Import internal packages: logger, db, queue
       - `main()` function:
         a) Create context with cancellation
         b) Set up signal handling: listen for SIGTERM and SIGINT, cancel context on signal
         c) Initialize database pool via db.NewPool(ctx) -- log and exit on failure
         d) Defer pool.Close()
         e) Initialize Redis client via queue.NewRedisClient(ctx) -- log and exit on failure
         f) Defer rdb.Close()
         g) Log "Fulfillment Worker started, consuming from fulfillment_queue"
         h) Define handler function `processOrder(ctx, msg OrderMessage) error`:
            - Log "Processing order {order_id}" with correlation_id
            - Update order status to "processing": db.UpdateOrderStatus(ctx, pool, msg.OrderID, "processing")
            - Simulate processing time: time.Sleep(500ms to 2s random) -- this creates realistic latency variation visible in future observability tooling
            - Update order status to "fulfilled": db.UpdateOrderStatus(ctx, pool, msg.OrderID, "fulfilled")
            - Log "Order {order_id} fulfilled" with correlation_id and processing_duration_ms
            - Return nil on success, error on DB failure
         i) Call queue.Consume(ctx, rdb, processOrder)
         j) On context cancellation (shutdown signal), log "Fulfillment Worker shutting down"

    2. **services/fulfillment-worker/Dockerfile** - Multi-stage build:
       - Stage 1 (builder):
         - FROM golang:1.22-alpine AS builder
         - WORKDIR /app
         - COPY go.mod go.sum ./
         - RUN go mod download
         - COPY . .
         - RUN CGO_ENABLED=0 GOOS=linux go build -o /worker ./cmd/worker/
       - Stage 2 (runtime):
         - FROM alpine:3.19
         - RUN apk add --no-cache ca-certificates
         - COPY --from=builder /worker /worker
         - CMD ["/worker"]
       - Multi-stage keeps image small (~15MB vs ~1GB for full Go image)
       - Build context is services/fulfillment-worker/ (no shared files needed -- Go worker doesn't use proto)

    3. **Run `go mod tidy`** to resolve dependencies and generate go.sum:
       - After creating all Go files, run from services/fulfillment-worker/:
         `cd services/fulfillment-worker && go mod tidy`
       - This downloads dependencies and creates go.sum
       - If go is not available locally, the Dockerfile handles dependency download during build
  </action>
  <verify>
    - main.go implements signal handling for graceful shutdown
    - main.go initializes DB pool, Redis client, and starts consumer loop
    - main.go defines processOrder handler that updates status through pending->processing->fulfilled
    - processOrder includes simulated processing delay (time.Sleep)
    - Dockerfile uses multi-stage build (golang builder + alpine runtime)
    - `go vet ./...` passes (if Go is available locally)
    - Docker build succeeds: `docker build -t fulfillment-worker-test services/fulfillment-worker/`
  </verify>
  <done>
    Fulfillment Worker main entry point initializes DB and Redis connections with retry logic, consumes from fulfillment_queue via BRPop, processes orders by updating status (pending->processing->fulfilled) with simulated delay (500ms-2s), and shuts down gracefully on SIGTERM. Multi-stage Dockerfile produces minimal Alpine-based image.
  </done>
</task>

</tasks>

<verification>
- Go code compiles without errors
- Docker build succeeds for fulfillment-worker
- Worker defines complete processing pipeline: consume message -> update to processing -> simulate work -> update to fulfilled
- Queue consumer uses BRPop with timeout (not busy-wait)
- Graceful shutdown handles SIGTERM properly
- Structured JSON logging includes correlation_id from queue messages
- Database operations use connection pool with retry logic
</verification>

<success_criteria>
- Complete services/fulfillment-worker/ directory with standard Go project layout
- Worker consumes from Redis fulfillment_queue using BRPop
- Order processing: status transitions pending -> processing -> fulfilled with simulated delay
- PostgreSQL updates via pgx connection pool
- Graceful shutdown on SIGTERM (important for Docker stop)
- Structured JSON logging matching format of Python and Node.js services
- Multi-stage Dockerfile produces minimal (~15MB) Alpine-based image
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-services/01-04-SUMMARY.md`
</output>
