---
phase: 01-foundation-services
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker-compose.yml
  - .env.example
  - .env
  - proto/order.proto
  - db/init-scripts/01-schema.sql
  - db/init-scripts/02-seed.sql
  - nginx/nginx.conf
  - Makefile
autonomous: true

must_haves:
  truths:
    - "docker-compose.yml defines all core services with health checks and dependencies"
    - "PostgreSQL initializes with schema and seed data on first startup"
    - "Redis is configured and health-checked"
    - "Nginx config routes / to web-gateway upstream"
    - "Proto file defines OrderService with CreateOrder, GetOrder, and ListOrders RPCs"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Complete service orchestration with health checks"
      contains: "service_healthy"
    - path: "proto/order.proto"
      provides: "gRPC service contract shared by Node.js and Python"
      contains: "service OrderService"
    - path: "db/init-scripts/01-schema.sql"
      provides: "Database schema for products and orders tables"
      contains: "CREATE TABLE"
    - path: "db/init-scripts/02-seed.sql"
      provides: "Sample product data for realistic traffic"
      contains: "INSERT INTO products"
    - path: "nginx/nginx.conf"
      provides: "Reverse proxy routing to web-gateway"
      contains: "proxy_pass"
    - path: ".env.example"
      provides: "Environment variable template"
      contains: "POSTGRES_PASSWORD"
  key_links:
    - from: "docker-compose.yml"
      to: "db/init-scripts/"
      via: "volume mount to /docker-entrypoint-initdb.d"
      pattern: "docker-entrypoint-initdb"
    - from: "docker-compose.yml"
      to: "nginx/nginx.conf"
      via: "volume mount"
      pattern: "nginx.conf:/etc/nginx"
    - from: "nginx/nginx.conf"
      to: "web-gateway:3000"
      via: "upstream proxy_pass"
      pattern: "proxy_pass.*web_gateway"
---

<objective>
Create the complete project scaffolding for the Foundation Services phase: Docker Compose orchestration file defining all services with health checks and dependency ordering, shared protobuf contract, database initialization scripts with schema and seed data, Nginx reverse proxy configuration, environment variable template, and Makefile for common operations.

Purpose: Establishes the infrastructure skeleton that all three microservices (Plans 02-04) build upon. Without this foundation, services have no orchestration, no database schema, no shared gRPC contract, and no reverse proxy routing.

Output: docker-compose.yml with all service definitions, proto/order.proto, db/init-scripts/, nginx/nginx.conf, .env.example, Makefile
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-services/01-CONTEXT.md
@.planning/phases/01-foundation-services/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create shared contracts, database scripts, and Nginx config</name>
  <files>
    proto/order.proto
    db/init-scripts/01-schema.sql
    db/init-scripts/02-seed.sql
    nginx/nginx.conf
    .env.example
    .env
  </files>
  <action>
    Create the shared infrastructure files that all services depend on:

    1. **proto/order.proto** - gRPC service contract (proto3 syntax):
       - Package: `order`
       - Service `OrderService` with RPCs:
         - `CreateOrder(CreateOrderRequest) returns (CreateOrderResponse)` - create a new order
         - `GetOrder(GetOrderRequest) returns (Order)` - get order by ID
         - `ListOrders(ListOrdersRequest) returns (ListOrdersResponse)` - list recent orders
       - Messages: CreateOrderRequest (product_id int32, quantity int32), CreateOrderResponse (order_id int32, status string), GetOrderRequest (order_id int32), Order (id int32, product_id int32, quantity int32, status string, created_at string), ListOrdersRequest (limit int32), ListOrdersResponse (repeated Order orders)
       - This file is shared: Node.js loads it dynamically via @grpc/proto-loader, Python compiles it with grpcio-tools

    2. **db/init-scripts/01-schema.sql** - Database schema:
       - `CREATE TABLE IF NOT EXISTS products` (id SERIAL PRIMARY KEY, name VARCHAR(255) NOT NULL, price DECIMAL(10,2) NOT NULL, created_at TIMESTAMP DEFAULT NOW())
       - `CREATE TABLE IF NOT EXISTS orders` (id SERIAL PRIMARY KEY, product_id INTEGER REFERENCES products(id), quantity INTEGER NOT NULL CHECK (quantity > 0), status VARCHAR(50) DEFAULT 'pending', created_at TIMESTAMP DEFAULT NOW(), updated_at TIMESTAMP DEFAULT NOW())
       - Add index on orders.status for fulfillment worker queries
       - Use IF NOT EXISTS for idempotency

    3. **db/init-scripts/02-seed.sql** - Seed data:
       - Insert 10 products with realistic names and prices (Widget Alpha $19.99, Sensor Beta $49.99, etc.)
       - Insert 5 sample orders in various statuses (pending, processing, fulfilled)
       - Use ON CONFLICT DO NOTHING for idempotency (add unique constraint on products.name in schema)

    4. **nginx/nginx.conf** - Reverse proxy:
       - Worker processes: auto
       - Upstream `web_gateway` pointing to `web-gateway:3000`
       - Server listening on port 80
       - `location /` proxies to web_gateway with headers: Host, X-Real-IP, X-Forwarded-For, X-Request-ID ($request_id)
       - Access log format as JSON for structured logging readiness
       - Include `location /nginx-health` returning 200 for nginx's own health check

    5. **.env.example** and **.env** - Environment variables:
       - POSTGRES_USER=orderuser
       - POSTGRES_PASSWORD=orderpass
       - POSTGRES_DB=orderdb
       - REDIS_URL=redis://redis:6379
       - GRPC_ORDER_API_ADDR=order-api:50051
       - NODE_ENV=development
       - LOG_LEVEL=info
       - Create .env as a copy of .env.example (for local dev convenience)
       - Add .env to .gitignore if not already there
  </action>
  <verify>
    - All files exist at specified paths
    - proto/order.proto is valid protobuf syntax (check with: grep "syntax.*proto3" proto/order.proto)
    - SQL files contain CREATE TABLE and INSERT statements
    - nginx.conf contains upstream and proxy_pass directives
    - .env.example has all expected variables
  </verify>
  <done>
    Proto file defines OrderService with 3 RPCs. Schema creates products and orders tables with proper constraints. Seed data provides 10 products and 5 sample orders. Nginx routes all traffic to web-gateway. Environment template documents all required variables.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Docker Compose orchestration and Makefile</name>
  <files>
    docker-compose.yml
    Makefile
    .gitignore
  </files>
  <action>
    Create the complete Docker Compose file defining all services with health checks, dependency ordering, and named volumes. Also create a Makefile for common operations.

    1. **docker-compose.yml** - Full service orchestration (no version field -- modern Compose v2 doesn't need it):

       **Infrastructure services (no profiles - always start):**

       - `postgres`: image postgres:15-alpine, env_file .env, healthcheck (pg_isready -U orderuser -d orderdb, interval 5s, timeout 3s, retries 5, start_period 10s), volumes (postgres-data:/var/lib/postgresql/data, ./db/init-scripts:/docker-entrypoint-initdb.d:ro), ports 5433:5432 (non-standard host port to avoid conflicts)

       - `redis`: image redis:7-alpine, healthcheck (redis-cli ping, interval 3s, timeout 2s, retries 5, start_period 5s), ports 6380:6379 (non-standard host port)

       - `nginx`: image nginx:1.25-alpine, volumes (./nginx/nginx.conf:/etc/nginx/nginx.conf:ro), ports 80:80, depends_on web-gateway service_healthy, healthcheck (curl -sf http://localhost/nginx-health || exit 1 -- install curl in custom nginx Dockerfile or use wget). Actually, since we use nginx:alpine which has no curl, use: test: ["CMD-SHELL", "wget -qO- http://localhost/nginx-health || exit 1"], interval 5s, timeout 3s, retries 3

       **Application services (no profiles - always start):**

       - `web-gateway`: build ./services/web-gateway, env_file .env, environment (GRPC_ORDER_API_ADDR=order-api:50051, REDIS_URL=redis://redis:6379, PORT=3000, SERVICE_NAME=web-gateway), depends_on (order-api: service_healthy, redis: service_healthy), healthcheck (wget -qO- http://localhost:3000/health || exit 1, interval 5s, timeout 3s, retries 3, start_period 15s)

       - `order-api`: build ./services/order-api, env_file .env, environment (POSTGRES_HOST=postgres, POSTGRES_PORT=5432, REDIS_URL=redis://redis:6379, GRPC_PORT=50051, SERVICE_NAME=order-api), depends_on (postgres: service_healthy, redis: service_healthy), healthcheck (python -c "import socket; s=socket.create_connection(('localhost', 50051)); s.close()" || exit 1, interval 5s, timeout 3s, retries 3, start_period 15s). Use CMD-SHELL for the healthcheck.

       - `fulfillment-worker`: build ./services/fulfillment-worker, env_file .env, environment (POSTGRES_HOST=postgres, POSTGRES_PORT=5432, REDIS_URL=redis://redis:6379, SERVICE_NAME=fulfillment-worker), depends_on (postgres: service_healthy, redis: service_healthy, order-api: service_healthy)
         - No healthcheck for worker (it's a background consumer, not a server). Instead use a simple process check or omit.

       - `traffic-generator`: build ./traffic-generator, environment (TARGET_URL=http://nginx, SERVICE_NAME=traffic-generator), depends_on (nginx: service_healthy), ports 8089:8089 (control API)

       **Named volumes:** postgres-data

       **Networks:** default bridge is fine for Docker Compose

    2. **Makefile** - Common operations:
       - `up`: docker compose up -d
       - `down`: docker compose down
       - `restart`: docker compose restart
       - `logs`: docker compose logs -f
       - `logs-service`: docker compose logs -f $(SERVICE)
       - `status`: docker compose ps
       - `clean`: docker compose down -v (removes volumes for fresh start)
       - `reset`: clean + up
       - `health`: ./scripts/health-check.sh (will be created in Plan 06)
       - `stats`: docker stats --no-stream
       - `proto-gen`: Generate Python protobuf files from proto/order.proto
       - .PHONY declarations for all targets

    3. **Update .gitignore** - Add:
       - .env (but NOT .env.example)
       - postgres-data/
       - node_modules/
       - __pycache__/
       - *.pyc
       - vendor/ (Go)
  </action>
  <verify>
    - `docker compose config` validates the compose file without errors (services may not exist yet, but YAML structure is valid)
    - Makefile targets are defined (grep for key targets)
    - .gitignore includes .env
  </verify>
  <done>
    docker-compose.yml defines 7 services (postgres, redis, nginx, web-gateway, order-api, fulfillment-worker, traffic-generator) with health checks and dependency ordering. Makefile provides shortcuts for all common operations. .gitignore prevents committing secrets and generated files.
  </done>
</task>

</tasks>

<verification>
- docker-compose.yml passes `docker compose config` validation
- All infrastructure config files exist and have correct content
- Proto file defines complete OrderService contract
- Database init scripts are syntactically correct SQL
- Nginx config has proper upstream and proxy directives
- Environment template documents all variables needed by services
</verification>

<success_criteria>
- Complete docker-compose.yml with all 7 service definitions
- proto/order.proto with OrderService (CreateOrder, GetOrder, ListOrders)
- db/init-scripts/ with schema (products, orders tables) and seed data (10 products, 5 orders)
- nginx/nginx.conf routing all external traffic to web-gateway
- .env.example with all environment variables documented
- Makefile with up/down/clean/reset/logs/stats targets
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-services/01-01-SUMMARY.md`
</output>
