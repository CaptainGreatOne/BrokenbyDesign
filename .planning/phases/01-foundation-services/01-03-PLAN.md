---
phase: 01-foundation-services
plan: 03
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - services/web-gateway/src/server.js
  - services/web-gateway/src/grpc-client.js
  - services/web-gateway/src/redis-client.js
  - services/web-gateway/src/logger.js
  - services/web-gateway/src/routes.js
  - services/web-gateway/Dockerfile
  - services/web-gateway/package.json
autonomous: true

must_haves:
  truths:
    - "Web Gateway starts and listens on HTTP port 3000"
    - "POST /orders creates an order via gRPC call to Order API"
    - "GET /orders/:id retrieves an order via gRPC call to Order API"
    - "GET /orders lists recent orders via gRPC call to Order API"
    - "GET /health returns 200 with service status"
    - "All requests get a correlation ID (from X-Request-ID header or generated)"
    - "All operations emit structured JSON logs with correlation_id"
  artifacts:
    - path: "services/web-gateway/src/server.js"
      provides: "Express HTTP server with middleware"
      contains: "express"
    - path: "services/web-gateway/src/grpc-client.js"
      provides: "gRPC client to Order API"
      contains: "grpc.credentials.createInsecure"
    - path: "services/web-gateway/src/routes.js"
      provides: "REST endpoint handlers"
      contains: "router.post"
    - path: "services/web-gateway/src/logger.js"
      provides: "Structured JSON logging"
      contains: "JSON.stringify"
    - path: "services/web-gateway/Dockerfile"
      provides: "Container image for web-gateway"
      contains: "FROM node"
    - path: "services/web-gateway/package.json"
      provides: "Node.js dependencies"
      contains: "@grpc/grpc-js"
  key_links:
    - from: "services/web-gateway/src/routes.js"
      to: "services/web-gateway/src/grpc-client.js"
      via: "function calls to create/get/list orders"
      pattern: "grpcClient|createOrder|getOrder"
    - from: "services/web-gateway/src/grpc-client.js"
      to: "order-api:50051"
      via: "gRPC connection"
      pattern: "order-api:50051"
    - from: "services/web-gateway/src/server.js"
      to: "services/web-gateway/src/routes.js"
      via: "Express router mounting"
      pattern: "app.use.*routes"
---

<objective>
Build the Web Gateway Node.js microservice -- an Express HTTP server that receives external REST requests, translates them to gRPC calls to the Order API, and returns JSON responses. This is the external-facing entry point that Nginx routes traffic to.

Purpose: The Web Gateway demonstrates the REST-to-gRPC translation pattern common in microservices architectures. It receives human-readable HTTP requests, calls the internal gRPC Order API, and returns JSON. It propagates correlation IDs across the protocol boundary (HTTP header to gRPC metadata).

Output: Complete services/web-gateway/ directory with Express server, gRPC client, routes, structured logging, Dockerfile, and package.json
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-services/01-CONTEXT.md
@.planning/phases/01-foundation-services/01-RESEARCH.md
@.planning/phases/01-foundation-services/01-01-SUMMARY.md
@proto/order.proto
@docker-compose.yml
@.env
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Web Gateway gRPC client, Redis client, and logger</name>
  <files>
    services/web-gateway/src/grpc-client.js
    services/web-gateway/src/redis-client.js
    services/web-gateway/src/logger.js
    services/web-gateway/package.json
  </files>
  <action>
    Create the supporting modules for the Web Gateway:

    1. **services/web-gateway/package.json**:
       - name: "web-gateway"
       - version: "1.0.0"
       - main: "src/server.js"
       - scripts: { "start": "node src/server.js" }
       - dependencies:
         - express: "^4.18.0"
         - @grpc/grpc-js: "^1.10.0"
         - @grpc/proto-loader: "^0.7.0"
         - redis: "^4.6.0"
         - uuid: "^9.0.0"

    2. **services/web-gateway/src/logger.js** - Structured JSON logging:
       - Export function `log(level, message, metadata = {})` that writes JSON to stdout
       - Fields: timestamp (ISO 8601), level, service ("web-gateway"), message, spread metadata
       - Export convenience functions: `info(msg, meta)`, `error(msg, meta)`, `warn(msg, meta)`
       - Use console.log(JSON.stringify(entry)) for output

    3. **services/web-gateway/src/grpc-client.js** - gRPC client to Order API:
       - Load proto/order.proto using @grpc/proto-loader with options: keepCase true, longs String, enums String, defaults true, oneofs true
       - Create OrderService client connecting to GRPC_ORDER_API_ADDR env var (default: "order-api:50051") with insecure credentials
       - Export promisified wrapper functions that accept correlation_id:
         - `createOrder(correlationId, productId, quantity)` - returns Promise
         - `getOrder(correlationId, orderId)` - returns Promise
         - `listOrders(correlationId, limit)` - returns Promise
       - Each function creates gRPC Metadata with "x-correlation-id" header
       - Wrap callbacks in Promises for async/await usage in routes
       - Handle gRPC errors: map gRPC status codes to HTTP status codes (NOT_FOUND->404, INVALID_ARGUMENT->400, INTERNAL->500)
       - Log gRPC calls and responses using logger

    4. **services/web-gateway/src/redis-client.js** - Redis client for caching:
       - Create Redis client from REDIS_URL env var (default: "redis://redis:6379")
       - Connect with retry logic (reconnectStrategy with max retries)
       - Export functions:
         - `getCache(key)` - GET and JSON.parse, return null on miss
         - `setCache(key, value, ttlSeconds)` - SET with EX option, JSON.stringify value
       - Used for optional response caching (e.g., cache product lookups at gateway level)
       - Log connection status
       - Handle Redis being unavailable gracefully (cache miss, not error)
  </action>
  <verify>
    - package.json lists all required dependencies
    - grpc-client.js loads proto file and creates OrderService client
    - grpc-client.js passes correlation_id via gRPC metadata
    - redis-client.js connects to Redis with error handling
    - logger.js outputs JSON with timestamp, level, service fields
  </verify>
  <done>
    gRPC client wraps OrderService RPCs as Promises with correlation ID propagation via metadata. Redis client provides cache operations with graceful fallback. Logger outputs structured JSON. All dependencies declared in package.json.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Web Gateway Express server, routes, and Dockerfile</name>
  <files>
    services/web-gateway/src/server.js
    services/web-gateway/src/routes.js
    services/web-gateway/Dockerfile
  </files>
  <action>
    Create the HTTP server, route handlers, and Docker container:

    1. **services/web-gateway/src/routes.js** - Express router with REST endpoints:
       - `POST /orders` - Create order:
         - Parse JSON body: { product_id, quantity }
         - Validate: product_id required (integer), quantity required (integer, > 0)
         - Return 400 with error message on validation failure
         - Call grpcClient.createOrder(correlationId, productId, quantity)
         - Return 201 with { order_id, status }
         - Catch gRPC errors and return appropriate HTTP status
       - `GET /orders/:id` - Get order by ID:
         - Parse id from params (integer)
         - Call grpcClient.getOrder(correlationId, orderId)
         - Return 200 with order object
         - Return 404 if not found
       - `GET /orders` - List recent orders:
         - Parse optional query param `limit` (default 10, max 100)
         - Call grpcClient.listOrders(correlationId, limit)
         - Return 200 with { orders: [...] }
       - `GET /health` - Health check:
         - Return 200 with { status: "healthy", service: "web-gateway", uptime: process.uptime() }
       - `GET /` - Root endpoint:
         - Return 200 with { service: "web-gateway", endpoints: ["/orders", "/orders/:id", "/health"] }
       - All route handlers use req.correlationId set by middleware
       - Wrap all handlers in try/catch, log errors, return 500 on unexpected errors

    2. **services/web-gateway/src/server.js** - Express application:
       - Create Express app
       - Middleware (in order):
         a) JSON body parser (express.json())
         b) Correlation ID middleware: extract X-Request-ID header or generate UUID, attach to req.correlationId, set on response header
         c) Request logging middleware: log method, path, correlation_id on request start
         d) Response timing middleware: record start time, log duration on response finish
       - Mount routes from routes.js
       - Error handling middleware (catches unhandled errors, returns 500)
       - Listen on PORT env var (default 3000)
       - Log "Web Gateway started on port {PORT}"
       - Handle SIGTERM gracefully for Docker: close server, log shutdown

    3. **services/web-gateway/Dockerfile**:
       - FROM node:20-alpine
       - WORKDIR /app
       - COPY package.json package-lock.json* ./
       - RUN npm install --production
       - COPY proto/ /app/proto/ (shared proto directory -- needs build context at repo root)
       - COPY src/ /app/src/
       - EXPOSE 3000
       - CMD ["node", "src/server.js"]
       - Note: Like order-api, build context should be repo root: `build: { context: ., dockerfile: services/web-gateway/Dockerfile }`
       - Install wget in Alpine for health check: RUN apk add --no-cache wget
  </action>
  <verify>
    - server.js creates Express app with correlation ID middleware
    - routes.js defines POST /orders, GET /orders/:id, GET /orders, GET /health
    - routes.js validates request body for POST /orders
    - Dockerfile builds from node:20-alpine and installs wget for health checks
    - Docker build succeeds: `docker build -f services/web-gateway/Dockerfile -t web-gateway-test .`
  </verify>
  <done>
    Web Gateway Express server handles REST requests with correlation ID propagation. POST /orders validates input and calls gRPC CreateOrder. GET endpoints retrieve orders via gRPC. Health check endpoint returns service status. Request logging middleware captures method, path, duration, and correlation_id. Dockerfile builds with wget for health checks and shared proto access.
  </done>
</task>

</tasks>

<verification>
- Docker build succeeds for web-gateway
- Express server defines all required endpoints (POST /orders, GET /orders/:id, GET /orders, GET /health)
- gRPC client passes correlation_id via metadata on every call
- Correlation ID middleware generates or extracts X-Request-ID
- All request/response cycles are logged with structured JSON
- Request validation returns 400 for invalid POST /orders payloads
</verification>

<success_criteria>
- Complete services/web-gateway/ directory with server.js, routes.js, grpc-client.js, redis-client.js, logger.js
- REST API: POST /orders (create), GET /orders/:id (get), GET /orders (list), GET /health
- gRPC client translates REST calls to OrderService RPCs with correlation ID
- Correlation ID flows from HTTP X-Request-ID header to gRPC metadata
- Structured JSON logging on all requests with method, path, duration, correlation_id
- Dockerfile builds and runs successfully
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-services/01-03-SUMMARY.md`
</output>
