---
phase: 01-foundation-services
plan: 06
type: execute
wave: 4
depends_on: ["01-05"]
files_modified:
  - scripts/health-check.sh
  - scripts/smoke-test.sh
autonomous: false

must_haves:
  truths:
    - "Health check script verifies all 7 services are running and healthy"
    - "Smoke test creates an order through the full pipeline and verifies it was fulfilled"
    - "docker compose up starts the entire stack without errors"
    - "End-to-end flow works: HTTP request -> Nginx -> Web Gateway -> gRPC -> Order API -> DB + Redis queue -> Fulfillment Worker -> DB update"
  artifacts:
    - path: "scripts/health-check.sh"
      provides: "Automated health verification for all services"
      contains: "docker compose ps"
    - path: "scripts/smoke-test.sh"
      provides: "End-to-end integration test"
      contains: "curl"
  key_links:
    - from: "scripts/smoke-test.sh"
      to: "http://localhost:80/orders"
      via: "curl through Nginx to full service chain"
      pattern: "curl.*localhost.*orders"
    - from: "scripts/health-check.sh"
      to: "docker compose ps"
      via: "Docker container status check"
      pattern: "docker compose ps"
---

<objective>
Create health check and smoke test scripts, then perform end-to-end verification that the entire Foundation Services stack works. Build all images, start the stack, verify health, run smoke tests through the full order pipeline, and present results for user verification.

Purpose: This is the integration verification plan. All individual services have been built -- now we prove the whole system works together. The health check script becomes a reusable tool for the learner. The smoke test validates the complete request flow through all 3 communication patterns (REST, gRPC, Redis queue).

Output: scripts/health-check.sh, scripts/smoke-test.sh, verified running stack
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-services/01-CONTEXT.md
@.planning/phases/01-foundation-services/01-01-SUMMARY.md
@.planning/phases/01-foundation-services/01-02-SUMMARY.md
@.planning/phases/01-foundation-services/01-03-SUMMARY.md
@.planning/phases/01-foundation-services/01-04-SUMMARY.md
@.planning/phases/01-foundation-services/01-05-SUMMARY.md
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create health check and smoke test scripts</name>
  <files>
    scripts/health-check.sh
    scripts/smoke-test.sh
  </files>
  <action>
    Create scripts for automated verification of the Foundation Services stack:

    1. **scripts/health-check.sh** - Service health verification:
       - Shebang: #!/bin/bash
       - set -e for exit on error (but handle individual check failures gracefully)
       - Colors: GREEN, RED, YELLOW, NC for output formatting
       - Print header: "Foundation Services Health Check"
       - Check each service:
         a) Docker container status: `docker compose ps --format json` or `docker compose ps` and parse output
         b) For each expected service (postgres, redis, nginx, web-gateway, order-api, fulfillment-worker, traffic-generator):
            - Check container is running
            - Check health status (healthy/unhealthy/starting)
            - Print [PASS] or [FAIL] with service name and status
         c) HTTP endpoint checks:
            - Nginx: curl -sf http://localhost:80/nginx-health (or just http://localhost:80/)
            - Web Gateway health: curl -sf http://localhost:80/health
            - Traffic Generator: curl -sf http://localhost:8089/health
         d) Database check: docker compose exec -T postgres pg_isready -U orderuser -d orderdb
         e) Redis check: docker compose exec -T redis redis-cli ping
       - Summary: total checks, passed, failed
       - Exit code: 0 if all pass, 1 if any fail
       - Make executable: chmod +x

    2. **scripts/smoke-test.sh** - End-to-end integration test:
       - Shebang: #!/bin/bash
       - Colors for output
       - Print header: "Foundation Services Smoke Test"
       - Pre-check: Run health-check.sh first, abort if unhealthy
       - Test 1: Create an order
         - `curl -sf -X POST http://localhost:80/orders -H "Content-Type: application/json" -d '{"product_id": 1, "quantity": 2}'`
         - Extract order_id from response
         - Verify response has order_id and status "pending"
         - Print [PASS] or [FAIL]
       - Test 2: Get the created order
         - `curl -sf http://localhost:80/orders/$ORDER_ID`
         - Verify response has matching order_id
         - Print [PASS] or [FAIL]
       - Test 3: List orders
         - `curl -sf http://localhost:80/orders?limit=5`
         - Verify response has orders array
         - Print [PASS] or [FAIL]
       - Test 4: Wait for fulfillment (up to 15 seconds)
         - Poll GET /orders/$ORDER_ID every 2 seconds
         - Check if status changed from "pending" to "fulfilled"
         - Print [PASS] if fulfilled within timeout, [FAIL] if not
         - This validates the full async pipeline: Order API -> Redis queue -> Fulfillment Worker -> DB update
       - Test 5: Check traffic generator status
         - `curl -sf http://localhost:8089/status`
         - Verify mode is "steady" and total_requests > 0
         - Print [PASS] or [FAIL]
       - Test 6: Switch traffic mode
         - `curl -sf -X POST http://localhost:8089/mode/pause`
         - Verify response shows mode "pause"
         - `curl -sf -X POST http://localhost:8089/mode/steady`
         - Verify response shows mode "steady"
         - Print [PASS] or [FAIL]
       - Summary: total tests, passed, failed
       - Exit code: 0 if all pass, 1 if any fail
       - Make executable: chmod +x
       - Note: Use jq for JSON parsing if available, fall back to grep/sed if not. Check for jq at start: `command -v jq >/dev/null 2>&1 || { echo "jq recommended but not required"; }`
  </action>
  <verify>
    - Both scripts exist and are executable
    - health-check.sh checks all 7 services
    - smoke-test.sh tests the full order lifecycle (create -> get -> list -> fulfillment)
    - smoke-test.sh tests traffic generator mode switching
    - Scripts use colored output for readability
    - Scripts return appropriate exit codes
  </verify>
  <done>
    Health check script verifies all 7 Docker containers are running and healthy, plus HTTP endpoint checks for Nginx, Web Gateway, and Traffic Generator. Smoke test validates the complete order pipeline: create order via REST, verify gRPC flow to Order API, check async fulfillment via Redis queue to Worker, confirm DB status update to "fulfilled". Traffic generator mode switching verified.
  </done>
</task>

<task type="auto">
  <name>Task 2: Build and start the full stack, fix any integration issues</name>
  <files></files>
  <action>
    Build all Docker images and start the complete Foundation Services stack:

    1. Build all images: `docker compose build`
       - If any build fails, diagnose and fix the issue in the relevant service files
       - Common issues: missing files in COPY, wrong paths, dependency installation failures

    2. Start the stack: `docker compose up -d`
       - Monitor startup: `docker compose logs -f` (watch for 60 seconds)
       - Check for startup errors: connection refused, health check failures, crash loops

    3. Wait for all services to be healthy: poll `docker compose ps` for up to 120 seconds
       - All services should show "healthy" or "running" status
       - If any service is "unhealthy" or "restarting", check logs and fix

    4. Run health check: `./scripts/health-check.sh`
       - If any checks fail, diagnose and fix

    5. Run smoke test: `./scripts/smoke-test.sh`
       - If any tests fail, diagnose and fix
       - The most common integration issues:
         - gRPC connection between web-gateway and order-api (service names, ports)
         - Redis queue message format mismatch between Python publisher and Go consumer
         - Database connection strings not matching .env variables
         - Nginx not routing to web-gateway correctly
         - Proto file mismatch between Node.js loader and Python generated code

    6. If fixes are needed, update the relevant service files and rebuild:
       `docker compose up -d --build {service-name}`

    7. Verify resource usage: `docker stats --no-stream`
       - Confirm total memory usage is well within 12GB budget
       - Log actual memory usage for reference

    8. Leave the stack running for the checkpoint verification
  </action>
  <verify>
    - `docker compose ps` shows all 7 services running/healthy
    - `./scripts/health-check.sh` passes all checks (exit code 0)
    - `./scripts/smoke-test.sh` passes all tests (exit code 0)
    - `docker stats --no-stream` shows memory within budget
    - `docker compose logs traffic-generator` shows requests being sent
  </verify>
  <done>
    All 7 services built, started, and verified. Health check passes. Smoke test confirms end-to-end order flow (REST -> gRPC -> DB -> Redis queue -> Worker -> DB update). Traffic generator producing continuous baseline traffic. Memory usage within 12GB budget.
  </done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
    Complete Foundation Services stack with 3 polyglot microservices (Node.js Web Gateway, Python Order API, Go Fulfillment Worker), PostgreSQL, Redis, Nginx reverse proxy, and automated traffic generator. All running via docker compose up.
  </what-built>
  <how-to-verify>
    1. Check services are running: `docker compose ps` -- all 7 services should show healthy/running
    2. Create an order manually: `curl -X POST http://localhost:80/orders -H "Content-Type: application/json" -d '{"product_id": 1, "quantity": 3}'` -- should return order_id
    3. Check order was fulfilled: `curl http://localhost:80/orders/{order_id}` -- status should be "fulfilled" after a few seconds
    4. List orders: `curl http://localhost:80/orders` -- should show multiple orders
    5. Check traffic generator: `curl http://localhost:8089/status` -- should show steady mode with requests being sent
    6. Switch traffic mode: `curl -X POST http://localhost:8089/mode/burst` then `curl http://localhost:8089/status` -- should show burst mode
    7. Check logs are structured JSON: `docker compose logs web-gateway --tail=5` -- should show JSON-formatted log entries
    8. Check resource usage: `docker stats --no-stream` -- total memory should be well under 12GB
  </how-to-verify>
  <resume-signal>Type "approved" if the stack is working correctly, or describe any issues you observe</resume-signal>
</task>

</tasks>

<verification>
- All 7 Docker containers running and healthy
- Health check script passes (exit code 0)
- Smoke test passes (exit code 0) -- validates full order lifecycle
- Traffic generator producing baseline traffic in steady mode
- Memory usage within 12GB budget
- Structured JSON logs from all 3 application services
- Mode switching works for traffic generator
</verification>

<success_criteria>
- `docker compose up` starts all services without errors
- Health check script confirms all services healthy
- Smoke test validates: create order -> gRPC flow -> async fulfillment -> status update
- Traffic generator auto-starts and produces continuous requests
- All containers within 12GB RAM budget
- Structured JSON logging across all services with correlation IDs
- Traffic mode switching works (steady/burst/overload/pause)
- User verifies the stack is working correctly
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-services/01-06-SUMMARY.md`
</output>
