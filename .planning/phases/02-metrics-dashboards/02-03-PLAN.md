---
phase: 02-metrics-dashboards
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - prometheus/prometheus.yml
  - docker-compose.yml
  - services/order-api/Dockerfile
autonomous: true

must_haves:
  truths:
    - "Prometheus scrapes metrics from web-gateway, order-api, and fulfillment-worker"
    - "Prometheus scrapes container metrics from cAdvisor"
    - "Prometheus scrapes host metrics from Node Exporter"
    - "Prometheus itself is accessible on port 9090"
    - "cAdvisor is accessible on port 8081 (remapped to avoid fulfillment-worker conflict)"
    - "All scrape targets show UP status in Prometheus targets page"
    - "Prometheus has healthcheck for downstream depends_on"
    - "fulfillment-worker has HTTP-based healthcheck on metrics port 2112"
  artifacts:
    - path: "prometheus/prometheus.yml"
      provides: "Scrape configuration for all targets"
      contains: "scrape_configs"
    - path: "docker-compose.yml"
      provides: "prometheus, cadvisor, node-exporter service definitions with healthchecks; fulfillment-worker healthcheck added"
      contains: "prom/prometheus"
  key_links:
    - from: "prometheus/prometheus.yml"
      to: "web-gateway:3000/metrics"
      via: "static_configs target"
      pattern: "web-gateway:3000"
    - from: "prometheus/prometheus.yml"
      to: "order-api:8000/metrics"
      via: "static_configs target"
      pattern: "order-api:8000"
    - from: "prometheus/prometheus.yml"
      to: "fulfillment-worker:2112/metrics"
      via: "static_configs target"
      pattern: "fulfillment-worker:2112"
    - from: "docker-compose.yml"
      to: "prometheus/prometheus.yml"
      via: "volume mount"
      pattern: "prometheus.yml:/etc/prometheus/prometheus.yml"
---

<objective>
Deploy Prometheus, cAdvisor, and Node Exporter as Docker Compose services, with Prometheus configured to scrape all application services and infrastructure exporters. Also add healthcheck for fulfillment-worker (which now has an HTTP server from Plan 02) and ensure order-api Dockerfile exposes the metrics port.

Purpose: Prometheus is the central metrics collection engine. Without it running and scraping, there are no metrics to visualize. cAdvisor and Node Exporter provide container and host-level metrics respectively.
Output: Running Prometheus instance scraping 6 targets (3 apps + prometheus self + cAdvisor + node-exporter), plus working cAdvisor and Node Exporter containers, with all services properly health-checked.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-metrics-dashboards/02-RESEARCH.md
@.planning/phases/02-metrics-dashboards/02-01-SUMMARY.md
@.planning/phases/02-metrics-dashboards/02-02-SUMMARY.md

# Existing compose file to modify
@docker-compose.yml
@services/order-api/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Prometheus config, add all observability services to Docker Compose, and update service healthchecks</name>
  <files>
    prometheus/prometheus.yml
    docker-compose.yml
    services/order-api/Dockerfile
  </files>
  <action>
1. Create directory `prometheus/` at project root.

2. Create `prometheus/prometheus.yml` with:
   ```yaml
   global:
     scrape_interval: 15s
     evaluation_interval: 15s

   scrape_configs:
     - job_name: 'prometheus'
       static_configs:
         - targets: ['localhost:9090']

     - job_name: 'web-gateway'
       static_configs:
         - targets: ['web-gateway:3000']
       metrics_path: '/metrics'

     - job_name: 'order-api'
       static_configs:
         - targets: ['order-api:8000']
       metrics_path: '/metrics'

     - job_name: 'fulfillment-worker'
       static_configs:
         - targets: ['fulfillment-worker:2112']
       metrics_path: '/metrics'

     - job_name: 'cadvisor'
       static_configs:
         - targets: ['cadvisor:8080']
       scrape_interval: 10s

     - job_name: 'node-exporter'
       static_configs:
         - targets: ['node-exporter:9100']
   ```

3. Update `services/order-api/Dockerfile` to EXPOSE port 8000 in addition to the existing gRPC port. The metrics HTTP server (added in Plan 02-01) runs on port 8000. No host port mapping is needed -- Prometheus connects via Docker internal network.

4. Add a healthcheck to the `fulfillment-worker` service in `docker-compose.yml`. Plan 02-02 added an HTTP server with a `/health` endpoint on port 2112, so now we can use it:
   ```yaml
   healthcheck:
     test: ["CMD-SHELL", "wget -qO- http://localhost:2112/health || exit 1"]
     interval: 5s
     timeout: 3s
     retries: 3
     start_period: 10s
   ```

5. Add the following services to `docker-compose.yml`:

   **prometheus:**
   - image: `prom/prometheus:v3.5.1`
   - container_name: prometheus
   - volumes: `./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml:ro` and `prometheus-data:/prometheus`
   - command: `--config.file=/etc/prometheus/prometheus.yml --storage.tsdb.retention.time=7d --storage.tsdb.retention.size=5GB --web.enable-lifecycle`
   - ports: `9090:9090`
   - depends_on:
     - web-gateway: condition: service_healthy (already has HTTP healthcheck on :3000/health)
     - order-api: condition: service_healthy (existing gRPC socket healthcheck confirms service is running; metrics port 8000 starts at same time)
     - fulfillment-worker: condition: service_healthy (healthcheck added in step 4 above uses the HTTP metrics server on :2112/health)
   - healthcheck: `test: ["CMD-SHELL", "wget --spider -q http://localhost:9090/-/ready || exit 1"]`, interval: 5s, timeout: 3s, retries: 5, start_period: 15s
   - restart: unless-stopped
   - deploy resources: memory limit 1G, cpus 1.0, memory reservation 512M, cpus 0.5
   - logging: json-file, max-size 10m, max-file 3

   **cadvisor:**
   - image: `gcr.io/cadvisor/cadvisor:latest`
   - container_name: cadvisor
   - privileged: true
   - devices: `/dev/kmsg:/dev/kmsg`
   - volumes: `/:/rootfs:ro`, `/var/run:/var/run:ro`, `/sys:/sys:ro`, `/var/lib/docker/:/var/lib/docker:ro`, `/dev/disk/:/dev/disk:ro`
   - ports: `8081:8080` (NOTE: map to 8081 on host because cAdvisor uses 8080 internally)
   - restart: unless-stopped
   - deploy resources: memory limit 200M, cpus 0.5
   - logging: json-file, max-size 10m, max-file 3

   **node-exporter:**
   - image: `prom/node-exporter:latest`
   - container_name: node-exporter
   - command: `--path.rootfs=/host`
   - pid: host
   - volumes: `/:/host:ro,rslave`
   - ports: `9100:9100`
   - restart: unless-stopped
   - deploy resources: memory limit 100M, cpus 0.25
   - logging: json-file, max-size 10m, max-file 3

   NOTE on node-exporter: Do NOT use `network_mode: host` because it breaks Docker Compose DNS resolution. Prometheus scrapes node-exporter by container name, which only works on the default bridge network. Instead, mount the host filesystem and use the `--path.rootfs=/host` flag. Map port 9100 explicitly.

6. Add `prometheus-data` to the volumes section at the bottom of docker-compose.yml (alongside existing postgres-data).

7. Update the resource budget comment at the top of docker-compose.yml to reflect new totals:
   - Core services: ~5GB (unchanged)
   - Observability: Prometheus ~1GB + cAdvisor ~200MB + Node Exporter ~100MB = ~1.3GB
   - Total: ~6.3GB (within 12GB budget)

IMPORTANT: Do NOT remove or modify any existing service definitions (except adding the healthcheck to fulfillment-worker). Only ADD the three new services, the prometheus-data volume, and the fulfillment-worker healthcheck.

IMPORTANT: All three application services use `condition: service_healthy` in the Prometheus depends_on. This works because:
- web-gateway: already has an HTTP healthcheck (from Phase 1)
- order-api: already has a gRPC socket healthcheck (from Phase 1) -- this confirms the service is running; the metrics port 8000 starts in the same process
- fulfillment-worker: now has an HTTP healthcheck on :2112/health (added in this task, using the metrics server from Plan 02-02)

NOTE: Do NOT expose the application metrics ports to the host (no port mapping for 8000 or 2112). Prometheus accesses them via the Docker internal network. Only Prometheus (9090), cAdvisor (8081), and Node Exporter (9100) need host port mappings.
  </action>
  <verify>
Run `docker compose config` from the project root to validate the compose file syntax. Verify prometheus/prometheus.yml exists with 6 scrape jobs. Verify docker-compose.yml has prometheus, cadvisor, and node-exporter services. Verify prometheus-data volume is defined. Verify fulfillment-worker has a healthcheck. Verify order-api Dockerfile includes EXPOSE 8000. Verify Prometheus depends_on uses service_healthy for all three application services.
  </verify>
  <done>
prometheus/prometheus.yml exists with scrape configs for prometheus, web-gateway, order-api, fulfillment-worker, cadvisor, and node-exporter. docker-compose.yml includes prometheus (port 9090), cadvisor (port 8081), and node-exporter (port 9100) services with healthchecks, resource limits, and logging. fulfillment-worker has HTTP-based healthcheck on port 2112. order-api Dockerfile exposes port 8000 for metrics. Prometheus depends_on uses service_healthy for all application services. prometheus-data volume defined. Compose file validates with `docker compose config`.
  </done>
</task>

</tasks>

<verification>
1. `docker compose config` validates without errors
2. prometheus/prometheus.yml has 6 scrape jobs
3. docker-compose.yml has prometheus, cadvisor, node-exporter services
4. All new services have resource limits, logging, and restart policies
5. fulfillment-worker has healthcheck on metrics port 2112
6. order-api Dockerfile exposes port 8000
7. Prometheus depends_on uses service_healthy for web-gateway, order-api, and fulfillment-worker
8. prometheus-data volume is defined
</verification>

<success_criteria>
- Prometheus configured to scrape all 3 application services + cAdvisor + Node Exporter + itself
- cAdvisor has host filesystem mounts for container metrics
- Node Exporter has host filesystem mount for system metrics
- Resource budget stays within 12GB (new total ~6.3GB)
- All services follow existing conventions (resource limits, logging rotation, restart policy)
- Prometheus uses service_healthy for all application service dependencies (no service_started fallback)
</success_criteria>

<output>
After completion, create `.planning/phases/02-metrics-dashboards/02-03-SUMMARY.md`
</output>
