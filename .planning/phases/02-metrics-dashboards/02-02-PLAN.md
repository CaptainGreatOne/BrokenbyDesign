---
phase: 02-metrics-dashboards
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - services/fulfillment-worker/go.mod
  - services/fulfillment-worker/go.sum
  - services/fulfillment-worker/cmd/worker/main.go
  - services/fulfillment-worker/internal/metrics/metrics.go
  - services/fulfillment-worker/internal/queue/consumer.go
autonomous: true

must_haves:
  truths:
    - "fulfillment-worker exposes Prometheus metrics at GET :2112/metrics"
    - "Metrics include orders_processed_total counter with status label (success, error)"
    - "Metrics include order_processing_duration_seconds histogram"
    - "Metrics include default Go runtime metrics (goroutines, GC, memory)"
    - "HTTP metrics server runs alongside the Redis queue consumer without blocking"
  artifacts:
    - path: "services/fulfillment-worker/internal/metrics/metrics.go"
      provides: "Prometheus registry, counters, histograms, StartMetricsServer function"
      contains: "prometheus"
    - path: "services/fulfillment-worker/cmd/worker/main.go"
      provides: "Metrics server goroutine started before queue consumption"
      contains: "metrics.StartMetricsServer"
  key_links:
    - from: "services/fulfillment-worker/cmd/worker/main.go"
      to: "services/fulfillment-worker/internal/metrics/metrics.go"
      via: "import and goroutine start"
      pattern: "go metrics\\.StartMetricsServer|metrics\\.StartMetricsServer"
    - from: "services/fulfillment-worker/cmd/worker/main.go"
      to: "services/fulfillment-worker/internal/queue/consumer.go"
      via: "metrics observation in process handler"
      pattern: "metrics\\.(OrdersProcessed|ProcessingDuration)"
---

<objective>
Add Prometheus instrumentation to the fulfillment-worker (Go) service, including a new HTTP server goroutine to expose /metrics alongside the existing Redis BRPOP queue consumer loop.

Purpose: The fulfillment-worker has NO HTTP server currently -- it only runs a BRPOP loop. Adding an HTTP server goroutine is required so Prometheus can scrape its metrics. This is the most complex instrumentation because it adds a new server to an existing queue consumer.
Output: Working /metrics endpoint on port 2112 with order processing metrics and Go runtime metrics.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-metrics-dashboards/02-RESEARCH.md

# Service source files to modify
@services/fulfillment-worker/cmd/worker/main.go
@services/fulfillment-worker/internal/queue/consumer.go
@services/fulfillment-worker/go.mod
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create metrics package with Prometheus instrumentation</name>
  <files>
    services/fulfillment-worker/go.mod
    services/fulfillment-worker/go.sum
    services/fulfillment-worker/internal/metrics/metrics.go
  </files>
  <action>
1. Add the Prometheus Go client dependency. Run from the `services/fulfillment-worker/` directory:
   ```
   go get github.com/prometheus/client_golang/prometheus
   go get github.com/prometheus/client_golang/prometheus/promauto
   go get github.com/prometheus/client_golang/prometheus/promhttp
   ```
   This will update go.mod and create/update go.sum.

2. Create `services/fulfillment-worker/internal/metrics/metrics.go` with:
   - Package `metrics`
   - Import `prometheus`, `promauto`, `promhttp`, `net/http`, `log`, `fmt`
   - Define exported metric variables using `promauto.NewCounterVec` and `promauto.NewHistogramVec`:
     - `OrdersProcessed` - CounterVec with name `orders_processed_total`, help "Total orders processed by fulfillment worker", labels: `["status"]` (values will be "success" or "error")
     - `ProcessingDuration` - HistogramVec with name `order_processing_duration_seconds`, help "Time spent processing an order", labels: `["status"]`, buckets: `prometheus.DefBuckets`
     - `QueueDepth` - Gauge with name `fulfillment_queue_depth`, help "Current depth of the fulfillment queue" (for future use)
   - Define `StartMetricsServer(port int)` function that:
     - Creates a new `http.ServeMux`
     - Registers `promhttp.Handler()` at `/metrics`
     - Registers a simple health handler at `/health` that returns 200 "ok"
     - Starts `http.ListenAndServe` on the given port
     - Logs a message before starting: "Metrics server starting on port %d"
     - If ListenAndServe returns an error, logs it as fatal

IMPORTANT: Use `promauto` (not manual registration) so metrics are automatically registered with the default registry. This ensures Go runtime metrics (goroutines, GC, memory) are included automatically via the default promhttp.Handler().

Port 2112 is the conventional Go Prometheus metrics port (from the Rush song "2112"). Use this as the default.
  </action>
  <verify>
Run `cd /home/user/Desktop/ObservabilityAndPipelines/services/fulfillment-worker && go build ./...` to confirm the package compiles without errors. Verify the metrics.go file exports OrdersProcessed, ProcessingDuration, and StartMetricsServer.
  </verify>
  <done>
metrics.go package compiles. Exports OrdersProcessed (CounterVec), ProcessingDuration (HistogramVec), QueueDepth (Gauge), and StartMetricsServer function. go.mod includes prometheus/client_golang dependency.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire metrics into main.go and queue consumer</name>
  <files>
    services/fulfillment-worker/cmd/worker/main.go
    services/fulfillment-worker/internal/queue/consumer.go
  </files>
  <action>
1. Modify `services/fulfillment-worker/cmd/worker/main.go` to:
   - Import `"fulfillment-worker/internal/metrics"`
   - After initializing Redis client but BEFORE calling `queue.Consume()`, start the metrics server as a goroutine:
     ```go
     go metrics.StartMetricsServer(2112)
     ```
   - In the `processOrder` handler function, add metrics tracking:
     - At the start of the handler (right after `startTime := time.Now()`), no change needed -- startTime already exists
     - On successful completion (after the "Order fulfilled" log), observe duration and increment success:
       ```go
       duration := time.Since(startTime)
       metrics.ProcessingDuration.WithLabelValues("success").Observe(duration.Seconds())
       metrics.OrdersProcessed.WithLabelValues("success").Inc()
       ```
     - On error returns, observe duration and increment error:
       ```go
       metrics.ProcessingDuration.WithLabelValues("error").Observe(time.Since(startTime).Seconds())
       metrics.OrdersProcessed.WithLabelValues("error").Inc()
       ```
     - Add metrics tracking to BOTH error paths (the "processing" status update failure AND the "fulfilled" status update failure)

2. Update `services/fulfillment-worker/Dockerfile` to EXPOSE port 2112 if not already exposed.

3. Verify the complete flow: main.go starts metrics server goroutine on :2112, then starts queue consumer. The processOrder handler tracks duration and success/error counts on every order processed.

IMPORTANT: Do NOT modify the existing processing logic or timing. Only ADD metrics observation calls alongside existing code. The `startTime` and `duration` variables already exist in the handler -- reuse them for the success path and compute fresh for error paths.
  </action>
  <verify>
Run `cd /home/user/Desktop/ObservabilityAndPipelines && docker compose build fulfillment-worker` to confirm the image builds. Verify main.go contains `go metrics.StartMetricsServer(2112)` and the processOrder handler has metrics.OrdersProcessed and metrics.ProcessingDuration calls on both success and error paths.
  </verify>
  <done>
fulfillment-worker builds successfully. main.go starts metrics HTTP server on port 2112 as a goroutine before queue consumption begins. The processOrder handler tracks orders_processed_total and order_processing_duration_seconds for both success and error outcomes. /metrics endpoint serves default Go runtime metrics plus custom order processing metrics.
  </done>
</task>

</tasks>

<verification>
1. `docker compose build fulfillment-worker` completes without errors
2. `services/fulfillment-worker/internal/metrics/metrics.go` exists with exported metrics
3. `services/fulfillment-worker/cmd/worker/main.go` starts metrics server goroutine
4. `go build ./...` passes in the fulfillment-worker directory
</verification>

<success_criteria>
- fulfillment-worker has prometheus/client_golang dependency in go.mod
- HTTP metrics server runs on port 2112 alongside BRPOP consumer
- orders_processed_total counter tracks success/error
- order_processing_duration_seconds histogram tracks processing time
- Default Go runtime metrics (goroutines, GC, memory) exposed automatically
- Docker image builds successfully
</success_criteria>

<output>
After completion, create `.planning/phases/02-metrics-dashboards/02-02-SUMMARY.md`
</output>
