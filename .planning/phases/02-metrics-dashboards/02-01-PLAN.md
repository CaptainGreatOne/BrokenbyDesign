---
phase: 02-metrics-dashboards
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/web-gateway/package.json
  - services/web-gateway/src/server.js
  - services/web-gateway/src/metrics.js
  - services/order-api/requirements.txt
  - services/order-api/src/server.py
  - services/order-api/src/metrics.py
autonomous: true

must_haves:
  truths:
    - "web-gateway exposes Prometheus metrics at GET /metrics"
    - "order-api exposes Prometheus metrics at GET :8000/metrics"
    - "Both services track http_requests_total counter with method, route, status_code labels"
    - "Both services track http_request_duration_seconds histogram with method, route labels"
    - "Both services expose default runtime metrics (GC, memory, event loop)"
  artifacts:
    - path: "services/web-gateway/src/metrics.js"
      provides: "prom-client registry, counter, histogram, /metrics endpoint handler"
      contains: "prom-client"
    - path: "services/web-gateway/src/server.js"
      provides: "Metrics middleware wired into Express pipeline"
      contains: "metrics"
    - path: "services/order-api/src/metrics.py"
      provides: "prometheus-client counter, histogram, /metrics HTTP handler"
      contains: "prometheus_client"
    - path: "services/order-api/src/server.py"
      provides: "Metrics HTTP server started alongside gRPC server"
      contains: "metrics"
  key_links:
    - from: "services/web-gateway/src/server.js"
      to: "services/web-gateway/src/metrics.js"
      via: "require and middleware registration"
      pattern: "require.*metrics"
    - from: "services/order-api/src/server.py"
      to: "services/order-api/src/metrics.py"
      via: "import and thread start"
      pattern: "import.*metrics|from.*metrics"
---

<objective>
Instrument the web-gateway (Node.js/Express) and order-api (Python/gRPC) services with Prometheus client libraries, exposing /metrics endpoints with request counters, latency histograms, and default runtime metrics.

Purpose: Without application-level metrics endpoints, Prometheus has nothing to scrape from the core services. This is the foundation that makes all dashboards possible.
Output: Two services with working /metrics endpoints exposing http_requests_total, http_request_duration_seconds, and default runtime metrics.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-metrics-dashboards/02-RESEARCH.md

# Service source files to modify
@services/web-gateway/src/server.js
@services/web-gateway/src/routes.js
@services/web-gateway/package.json
@services/order-api/src/server.py
@services/order-api/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Instrument web-gateway with prom-client</name>
  <files>
    services/web-gateway/package.json
    services/web-gateway/src/metrics.js
    services/web-gateway/src/server.js
  </files>
  <action>
1. Add `prom-client` dependency (version 15.1.3) to `services/web-gateway/package.json`.

2. Create `services/web-gateway/src/metrics.js` that:
   - Creates a new `prom-client.Registry`
   - Calls `collectDefaultMetrics({ register })` to expose Node.js runtime metrics (GC, event loop lag, memory heap)
   - Creates `http_requests_total` Counter with labels: `method`, `route`, `status_code`
   - Creates `http_request_duration_seconds` Histogram with labels: `method`, `route`, `status_code` and buckets: `[0.001, 0.01, 0.1, 0.5, 1, 2, 5]`
   - Exports: `register`, `httpRequestCounter`, `httpRequestDuration`

3. Modify `services/web-gateway/src/server.js` to:
   - Import the metrics module: `const { register, httpRequestCounter, httpRequestDuration } = require('./metrics')`
   - Add a metrics middleware BEFORE the routes mount (`app.use('/', routes)`). The middleware should:
     - Record start time with `Date.now()`
     - On `res.on('finish')`, calculate duration in seconds, then call `.labels(method, route, statusCode).inc()` on the counter and `.labels(method, route, statusCode).observe(duration)` on the histogram
     - Use `req.route?.path || req.path` for the route label (matches existing logging pattern)
   - Add `/metrics` endpoint BEFORE routes mount: `app.get('/metrics', async (req, res) => { res.set('Content-Type', register.contentType); res.end(await register.metrics()); })`

IMPORTANT: The /metrics endpoint must be registered BEFORE the catch-all routes to avoid being intercepted. Place it after the existing logging/timing middlewares but before `app.use('/', routes)`.

Do NOT remove or modify the existing response timing middleware (lines 43-59). The metrics middleware is separate and additive.

Rebuild the Docker image is NOT needed at plan time -- that happens when docker compose builds.
  </action>
  <verify>
Run `cd /home/user/Desktop/ObservabilityAndPipelines && docker compose build web-gateway` to confirm the image builds without errors. Then check that `services/web-gateway/src/metrics.js` exists and exports register, httpRequestCounter, httpRequestDuration. Verify server.js imports metrics and has /metrics route.
  </verify>
  <done>
web-gateway Dockerfile builds successfully. server.js imports metrics.js and registers /metrics endpoint + request tracking middleware. metrics.js creates prom-client Registry with default metrics, http_requests_total counter, and http_request_duration_seconds histogram.
  </done>
</task>

<task type="auto">
  <name>Task 2: Instrument order-api with prometheus-client</name>
  <files>
    services/order-api/requirements.txt
    services/order-api/src/metrics.py
    services/order-api/src/server.py
  </files>
  <action>
1. Add `prometheus-client>=0.24.1` to `services/order-api/requirements.txt`.

2. Create `services/order-api/src/metrics.py` that:
   - Imports from `prometheus_client`: `Counter`, `Histogram`, `generate_latest`, `CONTENT_TYPE_LATEST`, `start_http_server`
   - Creates `grpc_requests_total` Counter with labels: `method`, `status` (since this is gRPC, use gRPC method names like CreateOrder, GetOrder, ListOrders, and status codes like OK, NOT_FOUND, INTERNAL)
   - Creates `grpc_request_duration_seconds` Histogram with labels: `method` and buckets: `[0.001, 0.01, 0.1, 0.5, 1, 2, 5]`
   - Creates `orders_created_total` Counter (no labels) to track total orders created
   - Exports a `start_metrics_server(port=8000)` function that starts `prometheus_client.start_http_server(port)` -- this runs a simple HTTP server on port 8000 that serves /metrics. The `start_http_server` from prometheus_client handles the /metrics endpoint automatically.
   - Exports a `track_grpc_call(method_name)` context manager or decorator that measures duration and increments counter with status

3. Modify `services/order-api/src/server.py` in the `serve()` function to:
   - Import metrics: `from metrics import start_metrics_server, grpc_requests_total, grpc_request_duration_seconds, orders_created_total`
   - Call `start_metrics_server(port=8000)` BEFORE starting the gRPC server (this starts a separate HTTP thread for /metrics)
   - In each RPC method (CreateOrder, GetOrder, ListOrders), wrap the logic to track:
     - Start time at method entry
     - Duration observation on the histogram at method exit
     - Counter increment with method name and gRPC status (OK, NOT_FOUND, INTERNAL)
     - Increment `orders_created_total` in CreateOrder on success

IMPORTANT: The prometheus_client `start_http_server` runs in a daemon thread and serves at `0.0.0.0:8000/metrics` by default. This is separate from the gRPC server on port 50051.

4. Update `services/order-api/Dockerfile` if needed to EXPOSE port 8000 in addition to the gRPC port.
  </action>
  <verify>
Run `cd /home/user/Desktop/ObservabilityAndPipelines && docker compose build order-api` to confirm the image builds without errors. Verify `services/order-api/src/metrics.py` exists with Counter, Histogram, and start_metrics_server. Verify server.py imports and calls start_metrics_server.
  </verify>
  <done>
order-api Dockerfile builds successfully. server.py starts a metrics HTTP server on port 8000 before the gRPC server. metrics.py defines grpc_requests_total counter, grpc_request_duration_seconds histogram, and orders_created_total counter. All gRPC methods track request count and duration.
  </done>
</task>

</tasks>

<verification>
1. `docker compose build web-gateway order-api` completes without errors
2. `services/web-gateway/src/metrics.js` exists and exports prom-client registry
3. `services/order-api/src/metrics.py` exists and exports start_metrics_server
4. Both services have /metrics endpoint wired into their startup
</verification>

<success_criteria>
- web-gateway has prom-client dependency and /metrics endpoint
- order-api has prometheus-client dependency and metrics HTTP server on port 8000
- Both services build successfully with docker compose build
- Metric names follow Prometheus conventions (_total suffix for counters, _seconds for duration histograms)
</success_criteria>

<output>
After completion, create `.planning/phases/02-metrics-dashboards/02-01-SUMMARY.md`
</output>
