---
phase: 03-centralized-logging
plan: 03
type: execute
wave: 1
depends_on: []
files_modified:
  - services/fulfillment-worker/internal/logger/logger.go
  - services/fulfillment-worker/cmd/worker/main.go
  - services/fulfillment-worker/internal/queue/consumer.go
  - services/fulfillment-worker/internal/db/db.go
autonomous: true

must_haves:
  truths:
    - "fulfillment-worker outputs plain text logs (not JSON) to stdout"
    - "Every log line includes timestamp, level, service name, handler, order/item ID, and message"
    - "fulfillment-worker occasionally emits realistic WARN and ERROR logs during normal operation"
  artifacts:
    - path: "services/fulfillment-worker/internal/logger/logger.go"
      provides: "Plain text log formatter with handler/ID extraction"
      contains: "func Info"
  key_links:
    - from: "services/fulfillment-worker/cmd/worker/main.go"
      to: "services/fulfillment-worker/internal/logger/logger.go"
      via: "logger.Info/Warn/Error calls with handler parameter"
      pattern: "logger.Info"
---

<objective>
Rewrite fulfillment-worker logging from JSON to plain text format and add realistic error patterns.

Purpose: fulfillment-worker must emit plain text logs matching the project-wide format for Loki collection. Realistic queue processing issues (retries, slow processing, item failures) give the learner genuine patterns to explore in Grafana.

Output: Updated logger.go with plain text formatting via fmt.Printf. All callers updated with consistent handler parameters. Occasional simulated processing delays and retry patterns.
</objective>

<execution_context>
@/home/user/.claude/get-shit-done/workflows/execute-plan.md
@/home/user/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-centralized-logging/03-RESEARCH.md
@services/fulfillment-worker/internal/logger/logger.go
@services/fulfillment-worker/cmd/worker/main.go
@services/fulfillment-worker/internal/queue/consumer.go
@services/fulfillment-worker/internal/db/db.go
</context>

<tasks>

<task type="auto">
  <name>Task 1: Rewrite logger.go to plain text format</name>
  <files>services/fulfillment-worker/internal/logger/logger.go</files>
  <action>
Replace the JSON logger with a plain text formatter using `fmt.Printf`.

The log format must be:

```
{timestamp} {LEVEL} fulfillment-worker {handler} {id} {key=value pairs} {message}
```

Change the function signatures to make `handler` a first-class parameter instead of burying it in fields:

```go
func Info(message, handler, id string, fields map[string]interface{})
func Warn(message, handler, id string, fields map[string]interface{})
func Error(message, handler, id string, err error, fields map[string]interface{})
```

Note: The current signatures are `Info(message, correlationID string, fields ...map[string]interface{})`. The new signatures change `correlationID` to `handler` as second param, add `id` as third param. This is a breaking change to callers but the callers are updated in Task 2.

Internal `log` function:
1. Timestamp: `time.Now().UTC().Format(time.RFC3339Nano)` (or `time.RFC3339` -- either works, use RFC3339 for cleaner output)
2. Level: uppercase, padded to 5 chars using `fmt.Sprintf("%-5s", level)`
3. Service: `fulfillment-worker` (hardcoded constant)
4. Handler: the handler parameter
5. ID: if non-empty, format as `item={id}` (since this service processes queue items)
6. Fields: iterate map, format as `key=value` pairs separated by spaces
7. Message: the message parameter

Remove: `encoding/json` import, `LogEntry` struct, `json.Marshal` call.

Example outputs:
- `2026-02-08T14:32:01Z INFO  fulfillment-worker ProcessQueue item=abc123 status=pending Processing queue item`
- `2026-02-08T14:32:01Z WARN  fulfillment-worker ProcessQueue item=abc123 attempt=2/3 reason=temporary error Processing failed, will retry`
- `2026-02-08T14:32:02Z ERROR fulfillment-worker ProcessQueue item=abc123 attempts=3 Max retries exceeded, moving to DLQ`

For the Error function, if `err` is non-nil, add `error={err.Error()}` to the fields automatically.

All output via `fmt.Printf` to stdout (not stderr).
  </action>
  <verify>
Read logger.go and confirm:
- No `encoding/json` import
- No `json.Marshal` calls
- Uses `fmt.Printf` for output
- Function signatures include handler and id parameters
  </verify>
  <done>logger.go outputs plain text with fmt.Printf, handler/id as explicit parameters, no JSON serialization</done>
</task>

<task type="auto">
  <name>Task 2: Update all callers with handler/id parameters and add realistic error patterns</name>
  <files>
    services/fulfillment-worker/cmd/worker/main.go
    services/fulfillment-worker/internal/queue/consumer.go
    services/fulfillment-worker/internal/db/db.go
  </files>
  <action>
Update all logger calls to match the new function signatures: `Info(message, handler, id, fields)`, `Warn(message, handler, id, fields)`, `Error(message, handler, id, err, fields)`.

**main.go** - Update main function:
- Startup/shutdown: `handler: "Main"`, `id: ""`
- Signal handling: `handler: "Main"`, `id: ""`
- Order processing handler: `handler: "ProcessOrder"`, `id: fmt.Sprintf("%d", msg.OrderID)`
- Status update calls: `handler: "ProcessOrder"`, `id: fmt.Sprintf("%d", msg.OrderID)`

Add realistic error simulation in the message handler:
- `import "math/rand"` (add to imports if not present)
- ~8% chance: log WARN "Processing taking longer than expected" with `handler: "ProcessOrder"`, `duration_ms` field set to random 500-2000, before proceeding normally
- ~3% chance: log WARN "Temporary database latency detected" with `handler: "ProcessOrder"` before the status update, then proceed normally

**consumer.go** - Update queue consumer:
- Connection: `handler: "RedisConnection"`, `id: ""`
- Queue operations: `handler: "QueueConsumer"`, `id: ""` (or message correlation ID when available)
- Message received: `handler: "QueueConsumer"`, `id: msg.CorrelationID`
- Parse errors: `handler: "QueueConsumer"`, `id: ""`

**db.go** - Update database operations:
- Connection: `handler: "DatabasePool"`, `id: ""`
- Order status update: `handler: "OrdersTable"`, `id: fmt.Sprintf("%d", orderID)` (or the order_id parameter)
- Order fetch: `handler: "OrdersTable"`, `id: fmt.Sprintf("%d", orderID)`

Add realistic error simulation:
- ~2% chance in UpdateOrderStatus: log WARN "Database write latency elevated" with `latency_ms` field

Important: Ensure `math/rand` is imported where needed. Use `rand.Float64() < 0.08` for probability checks. Error simulation is log-only -- actual processing continues normally.
  </action>
  <verify>
Run: `grep -rn "handler" services/fulfillment-worker/cmd/ services/fulfillment-worker/internal/ | grep -v "_test.go" | head -20` to confirm handler parameters present.
Run: `grep -rn "rand.Float64" services/fulfillment-worker/ | head -10` to confirm error simulation.
Verify the code compiles: `cd services/fulfillment-worker && go vet ./...` (if go toolchain available, otherwise just verify code reads correctly).
  </verify>
  <done>All fulfillment-worker logger calls use new handler/id signature, and realistic WARN simulation produces occasional log entries (~8% slow processing, ~3% db latency, ~2% write latency)</done>
</task>

</tasks>

<verification>
1. Read logger.go -- confirm plain text format, no JSON
2. Grep for handler strings across all fulfillment-worker source files
3. Grep for `rand.Float64` -- confirm realistic error patterns exist
4. All function signatures updated from old correlationID-based to new handler/id-based
</verification>

<success_criteria>
- fulfillment-worker logger outputs plain text in format: `timestamp LEVEL fulfillment-worker handler id details message`
- All callers use new handler/id parameters
- Realistic WARN simulation produces occasional log entries during normal traffic
- No JSON output from logger
- Service functionality unchanged
</success_criteria>

<output>
After completion, create `.planning/phases/03-centralized-logging/03-03-SUMMARY.md`
</output>
